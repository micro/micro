package converter

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/sirupsen/logrus"
)

const (
	openAPISpecFileName = "spec.json"
)

// Converter is everything you need to convert Micro protos into an OpenAPI spec:
type Converter struct {
	logger      *logrus.Logger
	openAPISpec *openapi3.Swagger
	sourceInfo  *sourceCodeInfo
}

// New returns a configured converter:
func New(logger *logrus.Logger) *Converter {
	return &Converter{
		logger: logger,
	}
}

// ConvertFrom tells the convert to work on the given input:
func (c *Converter) ConvertFrom(rd io.Reader) (*plugin.CodeGeneratorResponse, error) {
	c.logger.Debug("Reading code generation request")
	input, err := ioutil.ReadAll(rd)
	if err != nil {
		c.logger.Errorf("Failed to read request: %v", err)
		return nil, err
	}

	req := &plugin.CodeGeneratorRequest{}
	err = proto.Unmarshal(input, req)
	if err != nil {
		c.logger.Errorf("Can't unmarshal input: %v", err)
		return nil, err
	}

	// Create a new OpenAPI3 document to fill in with schemas and paths:
	c.openAPISpec = &openapi3.Swagger{
		Components: openapi3.Components{
			RequestBodies:   make(map[string]*openapi3.RequestBodyRef),
			Responses:       make(map[string]*openapi3.ResponseRef),
			SecuritySchemes: make(map[string]*openapi3.SecuritySchemeRef),
			Schemas:         make(map[string]*openapi3.SchemaRef),
		},
		Info: &openapi3.Info{
			Title:       "Micro API",
			Description: "Generated by protoc-gen-openapi",
			Version:     "1",
		},
		OpenAPI: "3.0.0",
		Paths:   make(openapi3.Paths),
	}

	// Add the DEV platform:
	c.openAPISpec.AddServer(
		&openapi3.Server{
			URL:         "https://api.m3o.dev",
			Description: "Micro DEV environment",
		},
	)

	// Add the LIVE platform:
	c.openAPISpec.AddServer(
		&openapi3.Server{
			URL:         "https://api.m3o.com",
			Description: "Micro LIVE environment",
		},
	)

	// Add the Micro auth mechanism:
	c.openAPISpec.Components.SecuritySchemes["MicroAPIToken"] = &openapi3.SecuritySchemeRef{
		Value: &openapi3.SecurityScheme{
			BearerFormat: "JWT",
			Description:  "Micro API token",
			Name:         "MicroAPIToken",
			Type:         "http",
			Scheme:       "bearer",
		},
	}

	c.logger.Debugf("Converting input: %v", err)
	return c.convert(req)
}

// Converts a proto file into an OpenAPI spec:
func (c *Converter) convertFile(file *descriptor.FileDescriptorProto) error {

	// Input filename:
	protoFileName := path.Base(file.GetName())

	// Get the proto package:
	pkg, ok := c.relativelyLookupPackage(globalPkg, file.GetPackage())
	if !ok {
		return fmt.Errorf("no such package found: %s", file.GetPackage())
	}
	c.openAPISpec.Info.Title = strings.Title(strings.Replace(pkg.name, ".", "", 1))

	// Process messages:
	for _, msg := range file.GetMessageType() {

		// Convert the message:
		c.logger.Infof("Generating component schema for message (%s) from proto file (%s)", msg.GetName(), protoFileName)
		componentSchema, err := c.convertMessageType(pkg, msg)
		if err != nil {
			c.logger.Errorf("Failed to convert (%s): %v", protoFileName, err)
			return err
		}

		// Add the message to our component schemas (we'll refer to these later when we build the service endpoints):
		componentSchemaKey := fmt.Sprintf("%s.%s", pkg.name, componentSchema.Title)
		c.openAPISpec.Components.Schemas[componentSchemaKey] = openapi3.NewSchemaRef("", componentSchema)
	}

	// Process services:
	for _, svc := range file.GetService() {

		// Convert the service:
		c.logger.Infof("Generating service (%s) from proto file (%s)", svc.GetName(), protoFileName)
		servicePaths, err := c.convertServiceType(file, pkg, svc)
		if err != nil {
			c.logger.Errorf("Failed to convert (%s): %v", protoFileName, err)
			return err
		}

		// Add the paths to our API:
		for path, pathItem := range servicePaths {
			c.openAPISpec.Paths[path] = pathItem
		}
	}

	return nil
}

func (c *Converter) convert(req *plugin.CodeGeneratorRequest) (*plugin.CodeGeneratorResponse, error) {
	res := &plugin.CodeGeneratorResponse{}

	// Parse the source code (this is where we pick up code comments, which become schema descriptions):
	c.sourceInfo = newSourceCodeInfo(req.GetProtoFile())

	generateTargets := make(map[string]bool)
	for _, file := range req.GetFileToGenerate() {
		generateTargets[file] = true
	}

	// We're potentially dealing with several proto files:
	for _, file := range req.GetProtoFile() {

		// Make sure it belongs to a package (sometimes they don't):
		if file.GetPackage() == "" {
			c.logger.Warnf("Proto file (%s) doesn't specify a package", file.GetName())
			continue
		}

		// Register all of the messages we can find:
		for _, msg := range file.GetMessageType() {
			c.logger.Debugf("Loading a message (%s/%s)", file.GetPackage(), msg.GetName())
			c.registerType(file.Package, msg)
		}

		if _, ok := generateTargets[file.GetName()]; ok {
			c.logger.Debugf("Converting file (%s)", file.GetName())
			if err := c.convertFile(file); err != nil {
				res.Error = proto.String(fmt.Sprintf("Failed to convert %s: %v", file.GetName(), err))
				return res, err
			}
		}
	}

	// Marshal the OpenAPI spec:
	marshaledSpec, err := json.MarshalIndent(c.openAPISpec, "", "  ")
	if err != nil {
		c.logger.Errorf("Unable to marshal the OpenAPI spec: %v", err)
		return nil, err
	}

	// Add a response file:
	res.File = []*plugin.CodeGeneratorResponse_File{
		{
			Name:    proto.String(openAPISpecFileName),
			Content: proto.String(string(marshaledSpec)),
		},
	}

	return res, nil
}
